[{"content":"Hello 你好，这是，这里面是记录我对自己的博客web更新的日记。\nMarch 10，2023 博客使用hugo了\nApril 20, 2023 我使用了图床，蛮好用的 😁\nApril 25, 2023 我更新了一些社交方式\n更新一下我的博客的配置\nMar 10，2024 好久不见了，这一次我把近一年的笔记进行一个整理，然后更新到了博客上。 也做了许多的计划和之后的规划\n","permalink":"/zh-cn/posts/update/","summary":"Hello 你好，这是，这里面是记录我对自己的博客web更新的日记。 March 10，2023 博客使用hugo了 April 20, 2023 我使用了图床，蛮好用的 😁 April 25, 2023 我更新了一些","title":"博客搭建更新日记✨"},{"content":"思 这里面是我记录自己个人在学习过程中的一些对学习的看法和问题\n输出知识的法宝 对问题的提问 对于大多数的问题而言，有些在网上查找、询问资历高的同行等等方式。\n《提问的智慧》精读注解版 计算机的哲学 什么是抽象思维 什么是流水线 ","permalink":"/zh-cn/posts/issue/","summary":"思 这里面是我记录自己个人在学习过程中的一些对学习的看法和问题 输出知识的法宝 对问题的提问 对于大多数的问题而言，有些在网上查找、询问资历高的同行","title":"简单是稳定的前提"},{"content":"问题集锦 这是一个我在学习计算机时遇到或我自己提出的问题的集合\n计算机基础 对于Java来说，new是一个创建对象的过程，它存放在那个内存位置 计算机体系结构 为什么对于不同的计算机设计模式有着不一样的ISA？ 为什么说ISA的数量是一个需要控制的量，不可过多也不可过少？ 为什么指令集不能无限大？ 什么是callee什么是caller，它们有什么区别？ 为什么在编译语言中的跳转分支和测试是使用相反的条件来进行跳转代码会更有效率？ 为什么基于条件数据传送的代码会比基于条件控制转移的代码性能要好？ 处理器通过使用流水线(pipelining)来获得高性能，在流水线中，一条指令的处理要经过一系列的阶段，每个阶段执行所需操作的一小部分。基于条件数据传送的代码没有跳转操作，而是通过条件运算符直接将结果赋值给目标变量，因此可以避免跳转带来的开销。虽然在某些情况下，条件数据传送可能会产生一些额外的开销，但通常情况下，它的性能要优于基于条件控制转移的代码。\n在x86只有在主存分配了地址，寄存器没有分配实际地址，是吗？ 既然寄存器是快速的，为什么不能拥有很多个？ 汇编代码不会记录程序值的类型，理解这点这很重要。 汇编器和编译器有什么不同？ 计算机网络 计算机学术词汇 vector：在计算机里面不应该单纯的是数学上的“向量”，它应该是一个对于一个进程（或线程）来说是“多指引”（SIMD) 的和scalar 相对应的。是吗？ ","permalink":"/zh-cn/posts/questionscollection/","summary":"问题集锦 这是一个我在学习计算机时遇到或我自己提出的问题的集合 计算机基础 对于Java来说，new是一个创建对象的过程，它存放在那个内存位置 计算","title":"问题集锦（计算机）"},{"content":"gdb调试命令 gdb是一个在UNIX环境下的命令行调试工具\n进入gdb 1 2 3 4 # 先进入编译 gcc \u0026lt;program\u0026gt;.c -g -o \u0026lt;program\u0026gt; # 编译后在 gdb \u0026lt;program\u0026gt; 基本命令 1）查看源码　1 (gdb) l 源码会进行行号提示。\n如果需要查看在其他文件中定义的函数，在l后加上函数名即可定位到这个函数的定义及查看附近的其他源码。或者：使用断点或单步运行，到某个函数处使用s进入这个函数。\n2）设置断点　1 2 3 (gdb) b（reak） fun or (gdb) b row 这样会在运行到源码第6行时停止，可以查看变量的值、堆栈情况等；这个行号是gdb的行号。\n3）查看断点处情况　```c (gdb) info b\n1 2 3 4 5 可以键入\u0026#34;info b\u0026#34;来查看断点处情况，可以设置多个断点； #### 4）运行代码　```c (gdb) r 5）显示变量值　1 (gdb) p n 在程序暂停时，键入\u0026quot;p 变量名\u0026quot;(print)即可；\nGDB在显示变量值时都会在对应值之前加上 $N 标记，它是当前变量值的引用标记，以后若想再次引用此变量，就可以直接写$N，而无需写冗长的变量名；\n6）观察变量　1 (gdb) watch n 在某一循环处，往往希望能够观察一个变量的变化情况，这时就可以键入命令\u0026quot;watch\u0026quot;来观察变量的变化情况，GDB在\u0026quot;n\u0026quot;设置了观察点；\n7）单步运行　1 (gdb) n 8）程序继续运行　1 (gdb) c 使程序继续往下运行，直到再次遇到断点或程序结束；\n完整的gdb调试 退出gdb 1 2 # 输入\u0026#39;q\u0026#39; (gdb) q （施工中🚧）\n","permalink":"/zh-cn/posts/gdbdebug/","summary":"gdb调试命令 gdb是一个在UNIX环境下的命令行调试工具 进入gdb 1 2 3 4 # 先进入编译 gcc \u0026lt;program\u0026gt;.c -g -o \u0026lt;program\u0026gt; # 编译后在 gdb \u0026lt;program\u0026gt; 基本命令 1）查看源码 1 (gdb) l 源","title":"GDB基本使用"},{"content":"MakeFile的编译和连接 对于大量的c语言文件一个很好的自动化工具,其实可以用到任何语言\nMakeFile的一般使用 使用规则 既然要用MakeFile，那就要知道它是怎么使用的；主要还是编译\u0026amp;链接，将大量的文件，通过直接或间接的方式来一键编译，就不必像gcc -g -o pro1.c pro2.c pro3.c... filename如此这般麻烦的编译了。\n写入Make的文件的规则：\n如果这个工程没有编译过，那么我们的所有c文件都要编译并被链接。 如果这个工程之中的某几个c文件被修改，那么我们只编译被修改的c文件，并链接目标程序。 如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的c文件，并链接目标程序。 对makefile的书写规则：\n1 2 3 4 target ... : prerequisites ... command ... ... target: 这个是的目标文件，也可以是一个执行文件，还可以是一个标签（label）。 prerequisites: 这个是一个依赖文件，是对target文件的输入。 command: 这个是对文件的命令具体操作。eg：cc -o file.h 简而言之，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。\nmake的使用技巧 变量的使用 在makefile里面也是可以使用变量的，但是这是不可变的(是不是有点矛盾),它更像是c语言里面的宏(#define)。\n1 object = $(boo) 这样的好处是我们可以简化我们的make文件，是它不是这么的杂乱无章。\n书写规则 ","permalink":"/zh-cn/posts/makefile/","summary":"MakeFile的编译和连接 对于大量的c语言文件一个很好的自动化工具,其实可以用到任何语言 MakeFile的一般使用 使用规则 既然要用Make","title":"MakeFile使用笔记"},{"content":"资料来源: cs61c\ncache可以说是计算机技术革命中最伟大的想法了\n想一个问题：在我们的电脑里，指令是怎么控制内存里的东西的？因为我们要运行电脑除了CPU以外我们要向外拿取数据才能执行一系列的指令，这样电脑才算运行起来。\n让我们来看下面的这张图，这是十分完整的计算机组成结构：\nComponents of a Computer 我们可以从中看到在CPU需要运行一个进程的时候，首先会将指令告诉主存（main memory）,然后开始在主存中找地址（Address）找到后加载到在CPU内部通用寄存器（register）然后开始执行 执行完后再写入主存中。\n在这里面还有一个步骤，memory要先向disk中读取数据\n其实现实中，CPU通用寄存器的速度和主存之间存在着太大的差异。两者之间的速度大致如下关系： Oh!!!它们相差1,000倍左右，这是无法想像的，就比如当我前1ns的时候CPU已经做完了，而我还要等1000ns的memory的时间，因此在我们看来CPU此时是空闲的，大大的浪费了。\n因此，如果我们可以提升主存的速度，那么对于系统来说将会获得很大的性能提升。但我们试图提升主存的速度和容量，又期望其成本很低，这就有点难为人了。因此，我们有一种折中的方法，那就是制作一块速度极快但是容量极小的存储设备。那么其成本也不会太高。这块存储设备我们称之为cache。在硬件上，我们将cache放置在CPU和主存之间，作为主存数据的缓存。 当CPU试图从主存中load/store数据的时候， CPU会首先从cache中查找对应地址的数据是否缓存在cache 中。如果其数据缓存在cache中，直接从cache中拿到数据并返回给CPU。\n其实类比的话，我蛮喜欢CS61c里面的Library Analogy，而我自己的想法是有点像现在的物流运输：对一些物品都有一个主要的仓库，而也有一些本地仓，当我要送东西的时候我先去看看本地仓有没有，没有就再去主仓去看看，但时间上就没有本地仓的快\n[[2. Areas/01 Blog/03-ComputerSystems/cs61c/SRAM vs. DRAM vs. Disk]]\nMemory Hierarchy 好的现在我们知道了cache的出现了，而下面的图是说明了对于不同的内存级别 cache cache的级别 每一级的cache就是每一个下级内存的副本\ncahe的速度在一定程度上同样影响着系统的性能.当cache中没有缓存我们想要的数据的时候，依然需要漫长的等待从主存中load数据。为了进一步提升性能，引入多级cache。前面提到的cache，称之为L1 cache（第一级cache）。我们在L1 cache 后面连接L2 cache，在L2 cache 和主存之间连接L3 cache。等级越高，速度越慢，容量越大。\nTemporal Locality(时间局部性) If a memory location is referenced then it will tend to be referenced again soon\n比如说我用过一次这个地址,我保存起来以防我下次使用\nSpatial Locality(空间局部性) If a memory location is referenced, the locations with nearby addresses will tend to be referenced soon\n比如一个数组，在我读取的时候它会把数组左右的都读取了\nCache Hit vs Cache Miss 在我要对数据进行查找的时候会出现两种情况Cache Hit \u0026amp;Cache Miss.\ncache hit 你要查找的数据在缓存中 从缓存中检索数据并将其带到处理器.\ncache miss 你要查找的数据不在缓存中 去内存中找数据，把数据放到缓存中，带到处理器中\nCache的工作原理 现在我们来继续说一些快取的工作原理, 在此之前先来说一下的一些名词 什么是 line/tag/index/offset/valid\nline: 我们将cache平均分成相等的很多块，每一个块大小称之为cache line也可以叫cache block，其大小是cache line size。 tag: Used to identify the data(用于识别数据)。每条Cache Line前都会有一个独立分配的内存来存tag，其就是内存地址的前Nbits。 $$ addressbits - offsetbits $$ offset: Identifies the byte offset(标识字节偏移量)。一般是低位后几位。 $$ offset = log_2(line size) $$ index: 内存地址后续的bits则是在这\u0026ndash;Way的是Cache Line索引，可以索引Cache Line。 Valid bit: Tells you if the data stored at a given cache line is valid(告诉您存储在给定缓存行中的数据是否有效) 一个地址访问要映射到 Cache 中，地址被分成三个字段：tag，set index, block offset。这样，通过一个物理地址就可以获取数据或指令在缓存中的位置(set, way, byte))\nDirect mapped cache(直接映射缓存) 优点：直接映射缓存在硬件设计上会更加简单，因此成本上也会较低。\n一句话, 我一个个的加载进入cache,当我的cache满了我就转头再来一遍\n只适合于大容量Cache\n缺点: 继续访问下面的地址时，依然会cache缺失。这就相当于每次访问数据都要从主存中读取，所以cache的存在并没有对性能提升有效,有cache颠簸(每个主存块只有一个固定位置可存放，容易产生冲突)\nTwo-way set associative cache(两路组相连缓存) Cache分了2组\n优点:减少cache颠簸出现频率\n组相联映射实际上是直接映射和全相联映射的折中方案\n缺点: 增加硬件设计复杂读、成本较高(需要比较多个cache line的TAG)\nFully Associative Cache(全相连缓存) 优点:最大程度的降低cache颠簸的频率\n只适合于小容量Cache\n缺点: 增加硬件设计复杂读、成本较高(需要比较多个cache line的TAG)\n扩展：[[More Eviction Policies]]\n寻找 Hit 的电路\n[[Types of Misses]]\nComparisons 三个 cache 的区别之分 需补充\n","permalink":"/zh-cn/posts/cache/","summary":"资料来源: cs61c cache可以说是计算机技术革命中最伟大的想法了 想一个问题：在我们的电脑里，指令是怎么控制内存里的东西的？因为我们要运行电脑除了","title":"Cache Note"},{"content":"#入门\n微处理器历史 Intel的x86 在这里我想来简单的说道说道微处理器的历史发展，特此说明一下我不是专业的🙄，因此我没有详细的深入研究，如果有任何的错误请告诉我，谢谢。\n自从1971年的Intel4004既第一款微处理器，也是全球第一款微处理器开始，我们人类社会标志着进入微芯片时代，在这个时代有三个主要的趋势：\n处理器的位长的倍增 指令集的快速发展 时钟频率的快速增加 Intel也逐步发布了Intel 8008一个8位的，Intel 8086 一个16位的，至此，Intel的x86帝国开始了。在1985年，Intel的32位处理器IA32问世，而随着摩尔定律等的种种限制，单核的处理器已经遇到瓶颈了，各大公司继而转向了高频率、低功耗的多核处理器，处理器进入多核/多线程时代（2005）。\n在一些无论是竞争关系，还是研究关系，导致目前的市场上出现了两种指令集计算机\nCISC(Complex instruction set computer) RISC(Reduced instruction set computer) 在后面我会再提到的。\n我不知道未来的处理器向哪个方向发展，也不知道Intel是否一直在前沿（AMD：呵呵），但我相信，人类的智慧使得世界自第二次工业革命以来史无前例的大发展，在未来一定有着不一样的发展。\n基本概念 嗯嗯，回来回来，不去想未来，做好当下。\n在了解具体的体系系统前，我们来了解基本的一些东西：\n上面是来自CS61c的图片，我们现在要了解就是整个软件到硬件的过程，也可以说是抽象到具体的过程。\nInstructure Set Architecture：指令集架构 (包括指令规格，不同规则寄存器等)，简称ISA，它是软硬件之间的桥梁。\nProcessor、Memory、I/O system：这是由OS进行控制的。\n我们这章主要的是学习ISA，CSAPP主要是x86-64的CISC指令集，CS61c主要是RISC-V的RISC指令集，没错，它们是不同的指令集，在我的笔记里面我也会不时的写上RISC-V的一些表示来证明我学习过了（笑）。\n什么是编译 1 2 高级语言 --\u0026gt; 汇编语言 --\u0026gt; 机器语言 在我们的零章的时候我说过一个*.c文件如何变成的一个可执行的程序的一个主要过程，它有一个步骤是编译，这是一个我们需要细细品味的步骤。\n编译过程是一个由某个高级语言（比如c文件）经过编译器的一系列的处理成为可读性低的汇编语言。换而言之，就是把我们十分清楚明白的抽象语言转换成机器语言（值得注意的是，此时机器也不知道汇编语言），在经历汇编译器翻译成二进制代码，真正的机器语言，机器可以读懂了，但我们看不懂（除了某些黑客）。\n上面是cs61c中的从C到机器语言的完整过程，十分的详细了。程序的运行就是想像是一个翻译过程，用上一些我们明文规定的语法规则，使用编译器（GCC等）来当我们程序员和机器之间的翻译官。\n现在来看一看从 C语言 到机器代码(一个整型加法计算的汇编代码)\n1 2 3 4 5 6 7 8 9 10 11 12 // filename: clcyle_one #include \u0026lt;stdio.h\u0026gt; int main(int argc, char const *argv[]) { int sum = 0; for (int i = 0; i \u0026lt; 10; ++i) { sum += i; } return 0; } 经过gcc的编译，在自己的Linux机器上使用以下的代码\n1 $ gcc -Og -S clcyle_one.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 .file \u0026#34;clcyle_one.c\u0026#34; .text .globl main .type main, @function main: .LFB7: .cfi_startproc movl $0, %eax jmp .L2 .L3: addl $1, %eax .L2: cmpl $9, %eax jle .L3 movl $0, %eax ret #（不用在意类似 .file 的指令，它们是伪指令， 要从main看起） 两者相互比较一下我们可以发现，C 语言代码被处理成统一格式的汇编代码，在汇编代码中，第一个字符串叫做操作符，后面的是源和目的寄存器（这是一个大玩意😣）。操作和操作数明确，在下面我们会到不同的操作符分类分析（我想把RISC-V的加入作比较），记住一个条件，读取/运算操作是一个线性逐句逐次的操作，PC指令是有现态和次态之分。\n处理器的工作 在我们对操作指令分类讨论之前我们来认识处理器是怎么工作的，\n上面的图片(分别来自CSapp和CS61c)十分清楚的展示了处理器对于存放在主存里面的指令有着什么样的操作，主要的就两点存、读取值和计算。在x86-64里面还有一个叫作条件码的东东，我会在下面说到因为我也第一次看见这个。\n这是一个CPU到Memory的一个过程，具体的是一个处理器从内存某个地址取值（有数据和指令）拿到CPU里的寄存器通过ALU计算，再根据PC选择下一步。\n程序计数器(PC, Program counter) - 存着下一条指令的地址，在 x86-64 中称为 RIP。\n寄存器(Register) - 用来存储数据以便操作。\n条件代码(Codition codes) - 通常保存最近的算术或逻辑操作后的信息，用来做条件跳转的条件。\n什么是ISA Instruction Set Architecture (指令集框架) 是包含了针对某个特定处理器执行的基本操作码（opcode），里面是基本命令，在我们学习的x86-64、RISC-V都有不同的ISA。\n为了学习方便，我们一般要把ISA根据使用的方法不同进行不同的分类。\n资料处理与访问操作 算术逻辑操作 控制过程操作 在下面我会一一分析。\nCISC\u0026amp;RISC区别 CISC(Complex instruction set computer)\n兼容性性强，指令繁多，长度可变，由微程序实现。 代表：x86-64\nRISC(Reduced instruction set computer)\n指令少，使用频率接近，主要是依靠硬件实现（通用寄存器、硬布线逻辑控制）。 代表：RISC-V\n开始快乐的汇编 整型寄存器 在x86-64上有16个64位的通用寄存器；对于每个寄存器的低32、16和8位可以独立地通过其他不同指令名称访问，原则上，几乎任何寄存器都可以用于保存几乎任何逻辑和算术操作的操作数，但有些具有特殊或受限制的用途。\n一个寄存器有着64位、32位、16位、8位这可以对以前的低位程序向下兼容。\n按照惯例，%rsp被保留作为堆栈指针，并且因为一些指令（例如push、pop、call）隐含使用它。%rsp指向最低占用的堆栈位置（而不是下一个要使用的位置）。\n寄存器%rbp有时被用作帧指针，即当前堆栈帧的基址。指令计数器寄存器（％rip） 指向要执行的下一条命令; 程序员无法直接访问它, 但是大量地被用作基于位置无关代码寻址的基础。还有一些其他指令隐含地使用某些寄存器；例如，整数乘法和除法指令需要%rax和%rdx。\n数据类型 既然我们的寄存器有着不同位的表示，那就是说处理器在操作不同的数据时使用着不同位数的寄存器来提高速率。\n我们针对不同的数据类型使用不同的suffix和size：\nData type suffix size word char b 1B Byet short w 2B 1word int l 4B 2word long q 8B 4word char* q 8B 4word float s 4B 2word double l 8B 4word 上面的suffix列显示了在 GNU 汇编程序用来指定适当大小的变体的字母指示。\n而一个新单位word是相等于2个字节的大小。\n操作数指示符 操作数基本 以下的都是在操作数里面主要数值表达的意思：\nImm refers to a constant value, e.g. 0x8048d8e or 48 r refers to a register. e.g. %rax or %edi R[r] refers to the value stored in register address r. M[i] refers to the value stored at memory address i . 不同的格式表示不同的类型。\n寻址 很重要！！！\n对于寻址来说，比较通用的格式是：Imm(Rb, Ri, S) -\u0026gt; M[R[Rb] + S*R[Ri]+ Imm]，其中：\nImm - 常数偏移量 Rb - 基寄存器 Ri - 索引寄存器，不能是 %rsp S - 系数 指令 接下来我们就来看看不同分类的指令格式，我按书上的顺序来说的，它也是按我们在平时使用的频率顺序来教的。\n大多数的指令都是使用上文提过的 suffix 来显示操作数的大小的。\n数据移动指令 对于 mov 指令来说，需要源操作数和目标操作数。指令的具体格式可以这样写 mov? Src, Dest，第一个是源操作数，第二个是目标操作数\n1 2 3 4 5 6 mov[b|w|l|q] Src, Dest # 将src移动到dest movs[bw|bl|bq|wl|wq|lq] Src, Dest # 带符号扩展的移动 movz[bw|bl|bq|wl|wq] Src, Dest # 带零扩展的移动 movabsq imm, r # 移动绝对四字（imm为64位） cltq Src, Dest # 把%eax 符号扩展到%rax 在使用 mov 指令的时候需要值得注意的是我们的源值和目的值的选址是有标准的, 源操作数可以是立即数、寄存器值或内存值的任意一种，但目标操作数只能是寄存器值或内存值\nSrc Dest imm Rag imm Mem Reg Reg Reg Mem Mem Reg 只有这五种的选择 ， 如果要把Mem -\u0026gt; Mem 的值移动，需要两步 Mem -\u0026gt; Reg -\u0026gt; Mem\n程序栈指令 这一部分就只有两个主要的指令，但是无比的重要。可以把数据压入程序栈中，以及在栈中弹出，程序栈在过程调用中起至关重要的作用。\n1 2 pushq Src # 将4word的数据压入栈，并把%rsp - 8 -\u0026gt; %rsp popq Dest # 将4word的数据弹入栈，并把%rsp + 8 -\u0026gt; %rsp 对于程序栈指令十分重要的一点是我们对内存的变化要注意。在程序员的眼里内存是一个有限的数组，我们在把寄存器里面的数据 push 进内存的时候栈指针（%rsp）要向着地址减小的方向移动，这就是 %rsp - 8 的原因。\n图片\n算术与逻辑指令 对于算术指令我们想起CPU中最重要的部件 ALU 算术逻辑单元，基本上所有的这些指令通过 opcode 来在多路选择上 指挥 ALU正确的使用算术。\n\u0026gt; 注：下面的所有指令都可以根据数据类型加 suffix (b/w/l/q)\nUnary Operation(一元操作) 1 2 3 4 inc Deat Deat+1-\u0026gt;Deat # 按1递增 dec Deat Deat-1-\u0026gt;Deat # 按1递减 neg Deat -Deat-\u0026gt;Deat (取反) # 算术取反 not Deat ~Deat-1-\u0026gt;Deat （取补） # 按位取反 一元操作只有一个操作数，即做源也是目的。可以是Reg or Mem 。\nBinary Operation(二元操作) 1 2 3 4 5 6 7 leaq S，D \u0026amp;S -\u0026gt; D # 将源地址的有效地址加载到目标中 add S，D D + S -\u0026gt; D # 将源加到目标中 sub S，D D - S -\u0026gt; D # 将源从目标中减去 imul S，D D * S -\u0026gt; D # 目标乘以源 xor S，D D ^ S -\u0026gt; D # 按位异或目标和来源 or S，D D | S -\u0026gt; D # 按位或目标和来源 and S, D D \u0026amp; S -\u0026gt; D # 按位与目标和来源 对于第二个到最后一个不需要再说了，都是字面意思。主要来说一说 leaq 这个指令。\nLoad effective address(加载有效地址) , leaq 有两个作用：\n将其源操作数的有效地址（而不是该地址处的数据）加载到其目标寄存器中 在 C语言里面就是 \u0026amp;S , 这样的好处是可以给下面的内存产生指针。 也可用于执行与寻址无关的算术运算。（eg： leaq (%rdi, %rsi, 4), %rax 相同与 x + 4*y ) Shift Operations(移位操作) 1 2 3 sal[b|w|l|q] imm,d d = d \u0026lt;\u0026lt; imm # 左移imm位 sar[b|w|l|q] imm,d d = d \u0026gt;\u0026gt; imm # 算术右移imm位 shr[b|w|l|q] imm,d d = d \u0026gt;\u0026gt; imm # 逻辑右移imm位 Special Arithmetic Operations(特殊算术操作) 1 2 3 4 5 6 imulq S # 有符号全乘法 四字到八字 mulq S # 无符号全乘法 四字到八字 idivq S # 有符号全除法 八字到四字 divq S # 无符号全除法 八字到四字 cltd # sign extend %eax into %edx::%eax cqto # sign extend %rax into %rdx::%rax 在特殊算术里面，这样的设计是为了补码的乘除有扩展。由两个64位的到全128位的乘积和整数除法的截断。\n除法需要特殊的安排：idiv（有符号） 和 div（无符号） 操作在2n字节被除数和n字节除数上，产生一个n字节商和n字节余数。被除数总是存在于一对固定寄存器中（32位情况下为%edx和%eax；64位情况下为%rdx和%rax）；除数作为指令中的源操作数来指定。商放在％eax（resp. ％rax）中; 余数放在％edx（resp. ％rdx）中。对于有符号的除法，使用cltd（resp.ctqo）指令来准备％edx(resp.%rdx)，并将其与％eax(resp.%rax)的符号扩展配合使用。例如，如果a、b、c是保存四个字长的内存位置，则可以使用以下序列设置c = a / b：\n1 2 3 4 movq a(%rip), %rax ctqo idivq b(%rip) movq %rax, c(%rip) 上文来自文档）\n控制指令 到目前为止，我们看到的都是顺序一条接着一条的操作的，但是在我们的c语言里面还有条件语句（if）、循环语句（while）、分支语句（switch）等，很明显都不是顺序的，要进行某种跳转，而这种跳转是由机器代码来实现的，根据测试数据值来判断机器此时是否改变控制流。\n条件码 好了，到我们心心念的条件码了，条件码在CPU中是有单独的条件码寄存器，但是它只有单个位，它们描述的是距离最近的算术和逻辑操作的某些属性，CPU根据条件码寄存器来断定是否执行分支跳转。以下是四种条件码：\nZF result was Zero CF result caused Carry out of most significant bit (unsigned) SF result was negative (Sign bit was set) OF result caused (signed) Overflow （negative overflow, positive overflow） leaq 指令不改变任何的条件码。而不是所有的指令都要改变，如xor对于CF、OF会设置为0。\n指令集中也有专门来设置条件码的指令，它们不会改变任何的其他寄存器，只会改变条件码：\n1 2 3 4 cmp[b|w|l|q] s2,s1 # 比较两个值，S1 - S2 用减法的方法来比较 test[b|w|l|q] s2,s1 # 测试两个值，S1 \u0026amp; S2 可以来检查是负or正，也可以比较具体位的值 其实cmp和test有时是十分好用的测试指令，比如在对（x == 0）的时候，可以用 cmpl %eax, %eax 或者 testl %eax, %eax 来与自己比较来设置ZF条件码，也用来判断 %eax 是正数或负数。\n访问条件码 条件码通常是不会直接读取的，在x86中采用三种使用方式：\n可以根据条件码的某种位逻辑组合，将一个字节设置为0 或1。 可以条件跳转到程序的某个其他的部分。 可以有条件地传送数据。 这里会发现用了位的逻辑计算来确认大于或小于等情况。（需要好好看看第二章）\n第一点的实现 SET指令 1 2 3 4 5 6 7 8 9 10 11 12 sete / setz D Set if equal/zero ZF setne / setnz D Set if not equal/nonzero ~ ZF sets D Set if negative SF setns D Set if nonnegative ~ SF setg / setnle D Set if greater (signed) ~ (SF ^ 0F)\u0026amp; ~ ZF setge / setnl D Set if greater or equal (signed) ~ (SF ^ 0F) setl / setnge D Set if less (signed) SF^0F setle / setng D Set if less or equal (SF ^ OF)|ZF seta / setnbe D Set if above (unsigned) ~ CF\u0026amp; ~ ZF setae / setnb D Set if above or equal (unsigned) ~ CF setb / setnae D Set if below (unsigned) CF setbe / setna D Set if below or equal (unsigned) CF|ZF SET指令，每条指令根据条件码的各种组合将一个字节设置为 0或1。\n第二点的实现 Jump指令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 jmp Label Jump to label true jmp *Operand Jump to specified location true je / jz Label Jump if equal/zero ZF jne / jnz Label Jump if not equal/nonzero ~ ZF js Label Jump if negative SF jns Label Jump if nonnegative ~ SF jg / jnle Label Jump if greater (signed) ~ (SF ^ 0F)\u0026amp; ~ ZF jge / jnl Label Jump if greater or equal (signed) ~ (SF ^ 0F) jl / jnge Label Jump if less (signed) SF^0F jle / jng Label Jump if less or equal (SF ^ OF)|ZF ja / jnbe Label Jump if above (unsigned) ~ CF\u0026amp; ~ ZF jae / jnb Label Jump if above or equal (unsigned) ~ CF jb / jnae Label Jump if below (unsigned) CF jbe / jna Label Jump if below or equal (unsigned) CF|ZF 跳转(jump) 指令会导致执行切换到程序中一个全新的位置。在汇编代码中，这些跳转的目的地通常用一个标号(Label) 指明。在下一个标题再继续深入jump指令。\n第三点的实现 cmove指令 1 2 3 4 5 6 7 8 9 10 11 12 cmove / cmovz S, D Move if equal/zero ZF cmovne / cmovnz S, D Move if not equal/nonzero ~ ZF cmovs S, D Move if negative SF cmovns S, D Move if nonnegative ~ SF cmovg / cmovnle S, D Move if greater (signed) ~ (SF ^ 0F)\u0026amp; ~ ZF cmovge / cmovnl S, D Move if greater or equal (signed) ~ (SF ^ 0F) cmovl / cmovnge S, D Move if less (signed) SF^0F cmovle / cmovng S, D Move if less or equal (SF ^ OF)|ZF cmova / cmovnbe S, D Move if above (unsigned) ~ CF\u0026amp; ~ ZF cmovae / cmovnb S, D Move if above or equal (unsigned) ~ CF cmovb / cmovnae S, D Move if below (unsigned) CF cmovbe / cmovna S, D Move if below or equal (unsigned) CF|ZF 条件传送指令, 但传送条件满足的时候,指令把S复制到D中。\nC语言中的条件分支 现在来进行对C语言中一些常见的分支跳转操作来看看翻译后的机器代码。\nif-else C 语言中的江-else 语旬的通用形式模板如下：\n1 2 3 4 if (test-expr) then-statement else els-statement 汇编器工作是为 then-statement 和 else-statement 产生各自的代码块。它会插入条件和无条件分支，以保证能执行正确的代码块。\n看一个例子\n1 2 3 4 5 6 7 8 9 10 long absdiff(long x, long y) { long result; if (x \u0026lt; y) result = y-x; else result = x-y; return result; } 1 2 3 4 5 6 7 8 9 10 long absdiff_es(long x, long y) { long result; if (x \u0026gt; y) result = x-y; else result = y-x; return result; } 分别产生的汇编代码\n1 2 3 4 5 6 7 8 9 # x in %rdi, y in %rai absdiff : movq %rsi, %rax subq %rdi, %rax rval = y-x movq %rdi, %rdx subq %rsi, %rdx eval = x-y cmpq %rsi, %rdi 比较 x:y cmovge %rdx, %rax If \u0026gt;=, rval = eval ret Return tval 1 2 3 4 5 6 7 8 9 10 11 absdiff_es: cmpq %rsi, %rdi jle .L4 movq %rdi, %rax subq %rsi, %rax ret .L4: # x \u0026lt;= y movq %rsi, %rax subq %rdi, %rax ret [为什么基于条件数据传送(1)的代码会比基于条件控制转移(2)的代码性能要好？]\nwhile while 语句的通用形式如下：\n1 2 while (test-expr) body-statement 例子\n1 2 3 4 5 6 7 8 9 long fact_while(long n) { long result = 1; while (n \u0026gt; 1) { result *= n; n = n-1; } return result; } do-while do-while 语句的通用形式如下：\n1 2 3 do body-statement while (test-expr); 例子\n1 2 3 4 5 6 7 8 9 10 11 12 // Do While 的 C 语言代码 long pcount_do(unsigned long x) { long result = 0; do { result += x \u0026amp; 0x1; x \u0026gt;\u0026gt;= 1; } while (x); return result; } 产生的汇编代码\n1 2 3 4 5 6 7 8 9 movl $0, %eax # result = 0 .L2: # loop: movq %rdi, %rdx andl $1, %edx # t = x \u0026amp; 0x1 addq %rdx, %rax # result += t shrq %rdi # x \u0026gt;\u0026gt;= 1 jne .L2 # if (x) goto loop rep # ret for for 循环的通用形式如下：\n1 2 for (init-expr; test-expr; update-expr) body-statement switch switch 循环的通用形式如下：\n1 2 3 4 5 6 7 8 switch(n){ case test-expr: body-statement break; case test-expr: body-statement break; } 对于C语言的这些语法我只是在这里举出例子来，最好看看书上的讲解。\n分支跳转(RISC-V) 对于这个分类其实我分给了RISC-V， 主要是在x86-64中的控制指令和RISC-V的分支跳转其实是一回事，主要区别是否使用的条件码（其实在我看来RISC-V也用了条件码，但是是隐式的使用）。\nRISC-V的 Branch Instruction\n1 2 （施工中🚧） 过程调用 过程是软件中一种很重要的抽象。它提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。然后，可以在程序中不同的地方调用这个函数。设计良好的软件用过程作为抽象机制，隐藏某个行为的具体实现，同时又提供清晰简洁的接口定义，说明要计算的是哪些值，过程会对程序状态产生什么样的影响。不同编程语言中，过程的形式多样：函数(function) 、方法(method) 、子例(subroutine) 、处理函数(handler) 等等，但是它们有一些共有的特性。\n过程调用主要有三个机制：\n控制传递。包括如何开始执行过程代码，以及如何返回到开始的地方。本质上是代码执行地址的改变和切换。\n数据传递。调用函数时要传给函数一些参数，在返回函数时也可能会将一些函数计算结果以返回值形式返回给原函数。本质上是数据传入新过程，又传回原过程。\n内存管理。在过程进行时，如何分配内存空间；在过程返回后，如何销毁内存中存储的局部变量。\n数据存储分配 外部链接 摩尔定律\u0026mdash;Wiki\n微处理器\u0026mdash;Wiki\nThe 50 Year History of the Microprocessor\n芯片相关\u0026ndash; Cpu历史\u0026ndash;AMD系列\n芯片相关\u0026ndash; Cpu历史\u0026ndash;intel系列\n【读薄 CSAPP】贰 机器指令与程序优化\nRISC-V手册\nRISC-V基本指令集概述\n过程调用\n","permalink":"/zh-cn/posts/csapp02/","summary":"#入门 微处理器历史 Intel的x86 在这里我想来简单的说道说道微处理器的历史发展，特此说明一下我不是专业的🙄，因此我没有详细的深入研究，如果","title":"二.程序的机器级表示(CSAPP)"},{"content":" ","permalink":"/zh-cn/posts/csapp03/","summary":"","title":"三.处理器设计(CSAPP)"},{"content":"二进制系统的核心\u0026mdash;bit 众所周知，在计算机里面的所以数据都是由bit表示的，可能这与我们日常使用的十进制来说是十分不方便的，而要想从现实世界的十进制到二进制的过程需要一点点的改变。\n正如我们所想的一样，bit的表示符合物理的形式，更加的底层，也与数学上的息息相关。当我们终究是要从程序员的看发来看bit的，对我们来说，计算机就是通过对bit进行不同方式的编码和描述，来完成和执行不同的任务。\n信息存储 二进制和十六进制 下面是各个进制的转换:\n二进制 十进制 十六进制 二进制 十进制 十六进制 0000 0 0 1000 8 8 0001 1 1 1001 9 9 0010 2 2 1010 10 A 0011 3 3 1011 11 B 0100 4 4 1100 12 C 0101 5 5 1101 13 D 0110 6 6 1110 14 E 0111 7 7 1111 15 F 这是一个十分重要的表格，我们要记得它。\n位， 字节， 字（bit, Byte, word） 我们的一个位就是一bit， 一个字节就是8个bit， 一般32位字长机器一个字就是4个bit。\n如果你问我为什么要这么规定的话，我可以告诉你我也不知道，笑，可以去看看历史，我猜是这样的设计符合机器的一些特性。\n在C语言里面，所有的数据类型都有分配好的字节数，char：1字节、short：2字节、int：4字节、long： 4字节、float：4字节、double：8字节（均在32位机器上）等等。\n分配成这样：\n有规范，可以在不同的机器程序可以运行。 机器没有无限大的内存。 寻址和字节顺序 在内存里，我们把它们抽象成一个一定大的数组块，为每一均匀分布的地址块编上编号(图片)，因此我们要知道多字节的存储顺序，这对于我们在进行网络数据的发送/接收格式，阅读反汇编的时候等等有关系。\n大小端的判定：\n以下是我使用书中的代码看我的电脑是大端还是小端：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 typedef unsigned char *byte_pointer; void show_bytes(byte_pointer start, size_t len) { size_t i; for (size_t i = 0; i \u0026lt; len; i++) { printf(\u0026#34;%.2x \u0026#34;, start[i]); } printf(\u0026#34;\\n\u0026#34;); } void show_int(int x) { show_bytes((byte_pointer)\u0026amp;x, sizeof(int)); } int main(int argc, char const *argv[]) { short a = -12345; unsigned short ua = a; printf(\u0026#34;number = %d\\n\u0026#34;, a); show_int(a); printf(\u0026#34;number = %d\\n\u0026#34;, ua); show_int(ua); return 0; } ==========================\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; $ ./byte number = -12345 c7 cf ff ff number = 53191 c7 cf 00 00 // 我的电脑是小端的 // 系统Linux: Alpine apk-tools 2.12.9, compiled for x86_64. 位的Boolean Algebras 位的布尔运算可以看我的这一篇\n左移和右移的计算 这里我想着重的记下来： 对于左移\u0026lt;\u0026lt;\u0026amp; 右移\u0026gt;\u0026gt; 是对于位的计算，相比于右移来说左移比较简单，在移动的同时往最低位右边补 0 即可。右移的话有两种类型，一种是逻辑右移（左边补 0），另一种是算术右移（左边补符号位）。为什么会有这两种，因为对应无符号数和有符号数的运算是不同的计算方法。\nC语言上的logic计算 不必多言，做题：\n1 2 3 4 5 6 7 8 9 10 11 12 // P76 练习题2.44 int x = foo(); int y = bar(); unsigned ux = x; unsigned uy = y; x \u0026lt; 0 =\u0026gt; ((x * 2) \u0026lt; 0) ux \u0026gt;= 0 x \u0026amp; 7 == 7 =\u0026gt; (x\u0026lt;\u0026lt;30) \u0026lt; 0 ux \u0026gt; -1 x \u0026gt; y =\u0026gt; -x \u0026lt; -y 整数表示 无符号表示 无符号数（unsigned），就是在0~2[^w] - 1范围的数，w是表示字长。有一个重要的特性，就是每个介于0~2[^w]-1 之间的数都有唯一的一个w位的值编码。\nUMin = 0; UMax = 2[^w]−1; 补码表示 补码（Two\u0026rsquo; s Complement）， 就是在-2[^w-1] ~ 2[^w-1] - 1范围的数，补码的出现使得数据的表示得到最好的利用，在运算上和我们的计算自觉一样了，只有一个0没正负之分。\nTMin = -2[^w-1] TMax = 2[^w-1] - 1 我们可以从上面得到一些特性：\n|TMin| = |TMax| + 1 UMax = 2 |TMax| + 1 = 2 |TMin| - 1 整数运算 加法 考虑两个非负整数x 和y, 满足0 \u0026lt; x, y \u0026lt; 2[^w] 。每个数都能表示为w位无符号数字。然而， 如果计算它们的和，我们就有一个可能的范围0 \u0026lt; x+y \u0026lt; 2[^w+1]-2 。我们需要w+1位\n8 11 3（19） 1000 + 1011 = 10011 我们来想想补码的形式，两个数x，y满足-2[^w-1] \u0026lt; x, y \u0026lt; 2[^w-1]-1, 计算它们的和，我们就有一个可能的范围-2[^w] \u0026lt; x + y \u0026lt; 2[^w-1]-2。\n8 11 3（19） 1000 + 1011 = 10011 乘法 无符号数的乘法就是UMul(x,y) = x * y mod 2[^w]\n补码的乘法TMul(x,y) = U2T(x * y mod 2[^w])\n溢出 在我们的运算中（特别是很大的数）不仅仅只考虑算不算的对，还要考虑有没有溢出，一旦我需要的位变成w+1的十分你要十分注意了。\n[\r此时我们要用上扩展与截取：\n扩展：\n对于无符号数，用x位向量表示[xn-1,\u0026hellip;,x0] -\u0026gt;[0,0,0,0,xn-1,\u0026hellip;,x0],用0把剩下的位补齐 对于补码， 用x位向量表示[xn-1,\u0026hellip;,x0] -\u0026gt;[ xn-1,xn-1,xn-1,xn-1,\u0026hellip;,x0],用最高位xn-1把剩下的位补齐 截取： 对于无符号数，UAdd(u,v) = u+v mod 2[^w], UMult(u,v) = u * v mod 2[^w] 对于补码，先把数转换成无符号数再模运算最后再转换补码， TAdd(u,v) = U2T(u+v mod 2[^w]), TMult(u,v) = U2T(u * v mod 2[^w]) 类型转换 无符号数和补码的转换是对位的表示不同来达到转换的过程。\n浮点数（floating point） 关于浮点数，本质上就是我们如何使用二进制来表达一个很大或者很小的数 (类似科学计数法，但是编码上有显著的区别)。\n由于二进制的数值系统在表达能力上存在一定的限制 (位数的限制)，我们实际上没有办法表示所有的数，因此浮点数的设计需要认真的权衡和折中，既要考虑能够表达的范围，也要考虑表达的精度。\n浮点数是一种近似的数，和我们十进制中的小数（或分数）一样，比如：3/10 = 0.333！。所以浮点数在不论大小项目里面都是要十分小心的地方。\nIEEE 浮点表示 IEEE 浮点标准用V=(-1)[^s] M 2[^E]的形式来表示一个数：\n符号(sign) s 决定这数是负数(s=1) 还是正数(s=0), 而对于数值0的符号位解释 作为特殊情况处理(-0.0 = +0.0)。 尾数(significand) M 是一个二进制小数，它的范围是1~2-£, 或者是0~1 - £。 阶码(exponent) E 的作用是对浮点数加权，这个权重是2 的E 次幕（可能是负数） 。 将浮点数的位表示划分为三个字段，分别对这些值进行编码： 一个单独的符号位s 直接编码符号s 。 k 位的阶码字段exp=ek - 1 … e1,e0 编码阶码E 。 n 位小数字段frac= fn-1 \u0026hellip; f1,f0 编码尾数M, 但是编码出来的值也依赖于阶码字 段的值是否等千0 。 在开始时记住一些值的来源：E = exp - Bias；M = 1/0 + f\n规格化的值 当阶数 exp ≠ 000…0和 exp ≠ 111…1时，表示的其实都是规范化的值，这里只需要大概知道因为实数轴上原来连续的值会被规范到有限的定值上并且这些定值之间的间距也是不一样的，具体可以通过后面给出的例子来理解。\n当 exp 的位模式既不全为0(数值0), 也不全为(32位的255，64位的2047)的时候，frac可以随意取值；\nE = exp - Bias(2[^w-1] - 1) M = 1 + f; 例子：\n1 2 3 4 12345 = 0b0011.0000.0011.1001 = 1.1000000111001 * 2[^13] E = 13 = exp - 127 -\u0026gt; exp = 140; M = 1 + f = 1.1000000111001 -\u0026gt; f = 1000000111001; s(1) exp(8) frac(23) 0 10001100 10000001110010000000000 非规格化的值 当exp每一位都为0的时候，可以想象到这时候的数无限的接近数值0，可画个数轴来看，此时的 E = 1 - Bias而且M没有隐含的1表示了，M = f\n第一个功能就是表示0，0的时候exp位为0，frac位为0，符号位的不同使得-0/+0有相同的地方何不同的地方。\n非规格化数的另外一个功能是表示那些非常接近于0.0 的数。它们提供了一种属性，称为逐渐溢出(gradual underflow), 其中，可能的数值分布均匀地接近于0.0 。\n无穷大和NaN 最后一类数值是当指阶码全为1 的时候出现的。当小数域全为0时，得到的值表示无穷，当 s=O 时是 +∞ 或者是 s=1 时是 -∞ 。当我们把两个非常大的数相乘，或者除以零时，无穷能够表示溢出的结果。当小数域为非零时，结果值被称为\u0026quot;NaN\u0026quot;, 即“不是一个数(Not a Number)\u0026quot; 的缩写。一些运算的结果不能是实数或无穷，就会返回这样的NaN值，比如当计算sqrt(-1)或 (∞-∞) 时。在某些应用中，表示未初始化的数据时，它们也很有用处。\n练习 假设一个基于IEEE 浮点格式的5 位浮点表示，有1 个符号位、2 个阶 码位(k=Z) 和两个小数位(n=2) 。阶码偏置量是2[2-1] - 1 = 1 。下表中列举了这个5 位浮点表示的全部非负取值范围。使用下面的条件，填写表格中的空白项：\ne: 假定阶码字段是一个无符号整数所表示的值。\nE: 偏置之后的阶码值。\n2[^E]: 阶码的权重。\nf: 小数值。\nM: 尾数的值。\n2[^E] * M: 该数（未归约的）小数值。\nV: 该数归约后的小数值。\n十进制：该数的十进制表示。\n位 e E 2[^E] f M 2[^E]*M V 十进制 0 00 00 0 0 1 0/4 0/4 0/4 0 0.0 0 00 01 0 0 1 1/4 1/4 1/4 1/4 0.25 0 00 10 0 0 1 2/4 2/4 2/4 1/2 0.5 0 00 11 0 0 1 3/4 3/4 3/4 3/4 0.75 0 01 00 1 0 1 0/4 4/4 4/4 1 1.0 0 01 01 1 0 1 1/4 5/4 5/4 5/4 1.25 0 01 10 1 0 1 2/4 6/4 6/4 3/2 1.5 0 01 11 1 0 1 3/4 7/4 7/4 7/4 1.75 0 10 00 2 1 2 0/4 4/4 8/4 2 2.0 0 10 01 2 1 2 1/4 5/4 10/4 5/2 2.5 0 10 10 2 1 2 2/4 6/4 12/4 3 3.0 0 10 11 2 1 2 3/4 7/4 14/4 7/2 3.5 0 11 00 - - - - - - ∞ - 0 11 01 - - - - - - NaN - 0 11 10 - - - - - - NaN - 0 11 11 - - - - - - NaN - 浮点数的舍入 溢出 1 2 3 4 printf(\u0026#34;浮点数的溢出:\\n\\t\u0026#34;); printf(\u0026#34;(1e20 + (-1e20)) + 3.14 = %lf\\n\\t\u0026#34;, 1e20 + (-1e20) + 3.14); printf(\u0026#34;1e20 + (-1e20 + 3.14) = %lf\\n\u0026#34;, 1e20 + (-1e20 + 3.14)); 浮点数的加乘法 浮点数的加乘法是和我们想的不一样的，它不满足结合律，交换律的，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 x = a + b + c; y = b + c + d; // 编译器可能试图通过产生下列代码来省去一个浮点加法 t = b + c; x = a + t; y = t + d; // 但是对x来说，这个计算可能会产生于原始值不同的值,因为它使用了加法运算的不同结合方式 //浮点数的溢出: (1e20 + (-1e20)) + 3.14 = 3.140000 1e20 + (-1e20 + 3.14) = 0.000000 总结 这一章我们具体的学习了在机器上数的表示，我们用无符号数和补码来表示我的数值，用浮点数表示二进制的科学计数法，数与数的计算，它们是会有溢出的，用模运算来截断防止位溢出。 大多数C 语言实现遵循的原则是底层的位模式不变。在补码机器上，对于一个w 位的值，这种行为是由函数T2Uw 和U2Tw来描述的。C 语言隐式的强制类型转换会出现许多程序员无法预计的结果，常常导致程序错误。\n1 2 int y = (int)(double)y; 我的建议是通读一遍课本，课本比我写的好很多，我想表达的写不出来那个味道，而后再去看看视频会更加的理解。\n外部链接 IEEE754\u0026mdash;wiki 浮点数\u0026mdash;wiki\n","permalink":"/zh-cn/posts/csapp01/","summary":"\u003ch1 id=\"二进制系统的核心---bit\"\u003e二进制系统的核心\u0026mdash;bit\u003c/h1\u003e\n\u003cp\u003e众所周知，在计算机里面的所以数据都是由\u003cstrong\u003ebit\u003c/strong\u003e表示的，可能这与我们日常使用的十进制来说是十分不方便的，而要想从现实世界的十进制到二进制的过程需要一点点的改变。\u003c/p\u003e","title":"一.数的表示(CSAPP)"},{"content":"前言 有志，有识，有恒，则断无不成之事 我自己在2022年学习过CS61c，这门课主要是讲解了计算机的体系结构，终于踏入了计算机的门槛。计算机体系结构，这是一个计算机十分难啃的一门知识，内容之多、范围之广，无论里面的数的表示、编译原理、CPU的基本架构、内存、虚拟内存、流水线、线程级并行、I/O、OS、网络等等，每个方面都可以单独拎出来成为一门课程。而想要精通这些知识需要耗费大量的时间和精力，即使学习十年也不嫌少。哈哈哈。\n我对计算机的热爱促使我非正式地学习了CS61c（我也不是伯克利的学子，我就小二本的）过后，我发现，它给我的是课堂上没有的一些思想，比如：为什么？通过已经有的事实发出提问（即存在有缘由，而不是想当然的存在即真理）。\n在我上大学的时候我就知道一本神书《深入理解计算机系统》（即：《Computer Systems: A Programmer’s Perspective》），可是一直没有机会读一读（也看不懂 😂 ，也正是在有CS61c的基础上我想去好好的通读一遍它。\n这本书好在哪里？它是一本以程序员的视角来看计算机的底层机制，不需要你对物理，电子层面有多么高的水准来看计算机，如果有的话更好的（在这里就不得不吐槽国内的教学了）。它里面的内容也是十分的丰富，结合了计算机组成与体系结构，链接与装载，程序优化，内存存储层次，操作系统，网络等基础知识。\n好的，说那么多，我也想把我在学习的过程写下来这也不失成为我的一场回忆。\n学习目的 知其然而不知其所以然\n在看这本书的时候问问自己，这本书可以给我带来什么？我为什么要学习这本书？正如上面的这句话一样，况且我也不想做一个”代码的搬运工“。\n学到什么？ 可以对计算机底层系统有一个更加全面且深入的认识。 系统的理解计算机系统底层的工作原理。 写出更加健壮的、安全的代码。 走向现实层面的计算机。 打下编译原理、操作系统的基础。 等等 学习是要你静下心来，认真思考，积极动手的，用我的话来说就是：事无巨细\n计算机系统漫游 接下来就看看我们要学什么。\n信息bit化 人类与机器交互最大的问题是语言不通。让我们回到五六十年代，那时没有像现在这样方便的手机、iPad和电脑操作方式。那个\u0026quot;古老时代\u0026quot;没有图像、键盘或字符，只有打孔器、巨型电子管和满屋子的电线\u0026hellip;\u0026hellip;我们唯一能与计算机交流的方法就是通过电流和“疯狂”的思维。\n而随着物理学和数学的发展，计算机得以快速发展，并且我们开始使用二进制来与机器进行交互，这比以前好多了。\n但仍然存在一个问题：“为什么要使用二进制？”因为它适用于我们的电路（高/低电压）和逻辑门（0/1），似乎所有事情都变成了二进制。 我们在这里已经迈出了很大的步伐。\n在计算机领域里面，我们叫一个可以正常显示0/1的位叫bit，而后续的研究证明了一次性对8bit进行操作是十分成功的，因此1 Byte = 8 bit(注意大小写)，在后面我们的位越来越多，我们使用了十六进制。由此来看，人类是很富有想象力的种族。\n在后面的学习中，数值的表示是很重要的知识点，计算机就是为精准，快速计算这些数值，特别是浮点数（float）的计算而发展的。\n编译系统 1 2 3 4 5 6 7 8 9 10 int main() { printf(\u0026#34;Hello World\\n\u0026#34;); return 0; } 上面是一个简单的C语言程序，打印一个\u0026quot;Hello World\u0026quot;(并且换行)，但是，它要经过好几个步骤才能打印在你的屏幕上，分别是：编译(Compiler)，汇编(Assembler)，装载器(Loader)，链接器(Linker)。\n我们在这一部分将要学到从 高级语言 --\u0026gt; 汇编语言 --\u0026gt; 机器语言 这一过程的具体实现，这使我们能够更深入地了解系统的底层。。\nCPU基本结构 CPU（中央处理器），可以说是本世纪最伟大的发明了，一个小小的芯片装载着人类的智慧，这一部分我们要了解 CPU 的内部构造，下面是一张 CPU 的大致图片：\n这是一个复杂但十分有趣的部分，相信我，你会体会它的魅力的。\n操作系统 操作系统(Operating System)，是来控制电脑的执行硬件、软件资源，控制I/O操作，提供基本的用户互动等。\n它也负责加载程序、处理服务（如网络堆栈和文件系统）以及为多个程序复用资源，但它实际上是要负责隔离各个程序，使得一个给定的程序不会干扰另一个程序的内存或执行。\n网络通信 这一部分我也写了自己的学习笔记\n外部链接 Computer Science from the Bottom Up\n小土刀博主的『读薄』\nfengmuzi2003up主的计算机系统漫游\n","permalink":"/zh-cn/posts/csapp00/","summary":"前言 有志，有识，有恒，则断无不成之事 我自己在2022年学习过CS61c，这门课主要是讲解了计算机的体系结构，终于踏入了计算机的门槛。计算机体","title":"零.深入理解计算机系统(CSAPP)"},{"content":"前言 这是一个根据《计算机网络：自顶向下方法》为主要课本的个人学习笔记。\n导读 在学习计算机的时候不可避免的是网络这个和我们现代生活息息相关的部分。其实在我之前看来，网络是一种我们看不见的东西，它无处不在，你看看你手边的手机，现在眼前的电脑\u0026hellip;\u0026hellip;他们之间有一种莫名的联系，有无形的线使它们链接起来\n当今世界，计算机网络已经成为了人们生活中不可或缺的一部分，它的影响不仅仅只 限于信息交流领域，还涉及到了商业、政治、文化等各个方面。作为一个十分复杂的系统，计算机网络的出现极大地改变了社会的基本交流规律。通过数以万计的网络连接，世界各地的人或物之间得以深度联系，信息的交流、共享和传递变得更加快捷和方便。\n网络的连接也让人们之间的思想交流变得更加广泛、自由与便捷。在这个信息化的时代，网络已经成为了人们相互交流、了解世界的重要途径之一，它让人们能够更加深入地了解各种文化、传统和观点，从而更好地认识自己和他人，增进人类之间的理解和和谐。\n然而，与此同时，网络连接也带来了许多不稳定的因素，例如网络病毒、黑客攻击、网络诈骗等等。这些不利因素威胁着人们信息的安全和隐私，使得网络世界变得更加复杂和危险。因此，在使用网络的过程中，我们必须注意保护自己的信息安全，提高自我保护意识，防范网络风险。\n在我学习计算机网络的过程，《自顶向下》是一本十分优秀的教材，它通过逐层递进的方式，深入浅出地讲解了计算机网络的基本概念和原理，帮助读者快速入门，并逐渐提高自己的网络知识水平。通过学习这本书，可以让我们更好地了解网络的繁星点点，理解计算机网络的运作方式和工作原理，从而更好地掌握网络知识，提高我们的网络应用能力。\n外部链接 中科大郑烇、杨坚全套《计算机网络（自顶向下方法 第7版》\n","permalink":"/zh-cn/posts/internet-0/","summary":"前言 这是一个根据《计算机网络：自顶向下方法》为主要课本的个人学习笔记。 导读 在学习计算机的时候不可避免的是网络这个和我们现代生活息息相关的部分","title":"零.计算机网络导读"},{"content":"前言 在计算机里面，所有的数据都是以二进制来进行存储的, 那么，我们在计算的时候不仅仅要知道十进制的计算， 也要知道二进制的计算 （+、-、*、/），这些都是叫位运算，即将符号位共同参与运算的运算。\n位运算的种类 接下来来看看有哪些运算\n符号 描述 作用 + 加法 用二进制的方法进行加法运算 - 减法 用二进制的方法进行加法运算 \u0026amp; 与运算 两个位都为1时，结果才为1 | 或运算 两个位都为0时，结果才为0 ^ 异或运算 两个位相同为0，相异为1 ~ 反取 0反1，1反0 \u0026laquo; 左移运算 所有二进位全部左移位，高位丢弃，低位补0 \u0026raquo; 右移运算 所有二进位全部右移位，对无符号数，高位补0；有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移） 计算方式 加法和减法就不再过多赘述！！！\n\u0026lsquo;\u0026amp;\u0026rsquo; 与运算 和AND一样\n1 2 3 4 0 \u0026amp; 0 = 0 0 \u0026amp; 1 = 0 1 \u0026amp; 0 = 0 1 \u0026amp; 1 = 1 **负数**按*补码*形式参加按位与运算。\r\u0026lsquo;|\u0026rsquo; 或运算 和OR一样\n1 2 3 4 0 | 0 = 0 0 | 1 = 1 1 | 0 = 1 1 | 1 = 1 **负数**按 *补码* 形式参加按位或运算。\r\u0026lsquo;^\u0026rsquo; 异或运算 和AOR一样\n1 2 3 4 0 ^ 0 = 0 0 ^ 1 = 1 1 ^ 0 = 1 1 ^ 1 = 0 \u0026lsquo;~\u0026rsquo; 取反运算 与NOT一样\n1 2 ~1 = 0 ~0 = 1 \u0026lsquo;\u0026laquo;\u0026rsquo; 和 \u0026lsquo;\u0026raquo;\u0026rsquo; 左右位移运算 将一个运算对象的各二进制位全部左（右）移若干位左(右)边的二进制位丢弃，右边补0\n1 2 3 a = 1010 0101; # a \u0026lt;\u0026lt; (\u0026gt;\u0026gt;) n a \u0026lt;\u0026lt; 2 --------- \u0026gt; a = 1001 0100; a \u0026gt;\u0026gt; 2 --------- \u0026gt; a = 0010 1001; 总结 在进行计算的时候，计算机中的数在内存中都是以二进制形式进行存储的，用位运算就是直接对整数在内存中的二进制位进行操作，因此其执行效率非常高，在程序中尽量使用位运算进行操作，这不仅可以锻炼自己的二进制运算，还会大大提高程序的性能。\n外部链接 此博客参考菜鸟教程-C语言中的位运算\n","permalink":"/zh-cn/posts/bitsoperation/","summary":"\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\n\u003cp\u003e在计算机里面，所有的数据都是以二进制来进行存储的,\n那么，我们在计算的时候不仅仅要知道十进制的计算，\n也要知道二进制的计算 （+、-、*、/），这些都是叫位运算，即将符号位共同参与运算的运算。\u003c/p\u003e","title":"奇妙的位运算"},{"content":"前言 在我学习c语言的时候我在想计算机是怎么知道我在写什么的，后面在我学习到了cs61c后我知道了汇编语言和底层语言（计算机语言），而RISC很好的帮助我们深入计算机去了解汇编语言。\nRISC-v的寄存器功能 RV32 有 32 个寄存器，而编号从x0到x31，且这32个各有各的作用，对这 32 个寄存器的定义如下：其中 ABI 是寄存器的二进制接口的名称，可以在汇编中使用。\n寄存器编号 寄存器 ABI 名称 寄存器功能 x0 zero 全0寄存器 x1 ra 跳转返回指针 x2 sp 栈指针 x3 gp 全局指针 x4 tp 线程指针 x5 t0 临时存储器 x6 t1 临时存储器 x7 t2 临时存储器 x8 s0/fp 存储寄存器，框架指针 x9 s1 存储寄存器 x10 a0 函数参数寄存器（可用于返回值） x11 a1 函数参数寄存器（可用于返回值） x12-x17 a2-a7 函数参数寄存器 x18-x27 s2-s11 存储寄存器 x28-x31 t3-t6 临时存储器 RISC的指令集 RISC是有47个指令的，而这47个指令能完成所有的现代操作系统的运行基本要求。\n为了方便学习，将指令集进行分类\n6种基本整数指令集 整数运算指令：实现算术、逻辑、比较等运算。 具有 7 条算数运算指令，分别是 add, addi, sub, slt, sltu, slti, sltiu\n1 2 3 4 5 6 7 add rd, rs1, rs2 # 是将 rs1 和 rs2 相加并写入 rd 中 addi rd, rs1, imm # 是将 rs1 和 imm 相加 sub rd,rs1,rs2 # 是将 rs1 减去 rs2 并写入 rd 中 slt # 是有符号的比较指令，即 rs1 小于 rs2 则置 1，否者置 0 sltu # 是无符号的比较指令，即 rs1 小于 rs2 则置 1，否者置 0 slti # 是 rs1 小于立即数则置 1，否者置 0。 sltiu 分支转移指令：实现条件转移、无条件转移等运算，并且没有延迟槽。 加载存储指令：实现字节、半字、字的加载、存储操作，采用的都是寄存器相对寻址方式。 控制与状态寄存器访问指令：实现对系统控制与状态寄存器的原子读-写、原子读-修改、原子读-清零等操作。 系统调用指令：实现系统调用、调试等功能。 ","permalink":"/zh-cn/posts/risc-v/","summary":"前言 在我学习c语言的时候我在想计算机是怎么知道我在写什么的，后面在我学习到了cs61c后我知道了汇编语言和底层语言（计算机语言），而RISC","title":"RISC-v前言"},{"content":"介绍自己 我是一个大二在校学生，专业是CS；爱好打游戏,主要是一些模拟类游戏笑；在学习日语和英语（不会😥）；\n我喜欢计算机的高效和开源自由，我希望能结交到一些志同道合的小伙伴和前辈们；\n私たちの未来はみんなでつくる\n第三个博客 这个博客我将不定期的更新，想要做一名程序员，因为我是个新人，目标是星辰大海（bushi），还有在我进行自学的同时，我会把一些我的问题和心得分享出来，也希望看到的小伙伴能指点和讨论。\n最后 我不知道的是这个博客能维持多久，但是我会在力所能及的精力上来完成它，希望几年过后可以看到不一样的风采。\n我知道刚开始说这种话是不好的，但所谓计划赶不上变化罢了\n","permalink":"/zh-cn/about/","summary":"about","title":"About Me"}]