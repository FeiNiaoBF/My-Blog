[{"content":"Hello 你好，这是，这里面是记录我对自己的博客web更新的日记。\nMarch 10，2023 博客使用hugo了\nApril 20, 2023 我使用了图床，蛮好用的 😁\n","permalink":"https://clever-klepon-d14cb6.netlify.app/posts/update/","summary":"Hello 你好，这是，这里面是记录我对自己的博客web更新的日记。 March 10，2023 博客使用hugo了 April 20, 2023 我使用了图床，蛮好用的 😁","title":"博客搭建更新日记✨"},{"content":"思 这里面是我记录自己个人在学习过程中的一些对学习的看法和问题\n输出知识的法宝 对问题的提问 对于大多数的问题而言，有些在网上查找、询问资历高的同行等等方式。\n《提问的智慧》精读注解版 计算机的哲学 什么是抽象思维 什么是流水线 ","permalink":"https://clever-klepon-d14cb6.netlify.app/posts/issue/","summary":"思 这里面是我记录自己个人在学习过程中的一些对学习的看法和问题 输出知识的法宝 对问题的提问 对于大多数的问题而言，有些在网上查找、询问资历高的同行","title":"简单是稳定的前提"},{"content":"问题集锦 这是一个我在学习计算机时遇到或我自己提出的问题的集合\n计算机基础 对于Java来说，new是一个创建对象的过程，它存放在那个内存位置 计算机体系结构 为什么对于不同的计算机设计模式有着不一样的ISA？ 为什么说ISA的数量是一个需要控制的量，不可过多也不可过少？ 为什么指令集不能无限大？ 什么是callee什么是caller，它们有什么区别？ 为什么在编译语言中的跳转分支和测试是使用相反的条件来进行跳转代码会更有效率？ 在x86只有在主存分配了地址，寄存器没有分配实际地址，是吗？ 既然寄存器是快速的，为什么不能拥有很多个？ 汇编代码不会记录程序值的类型，理解这点这很重要。 汇编器和编译器有什么不同？ 计算机网络 计算机学术词汇 vector：在计算机里面不应该单纯的是数学上的“向量”，它应该是一个对于一个进程（或线程）来说是“多指引”（SIMD) 的和scalar 相对应的。是吗？ ","permalink":"https://clever-klepon-d14cb6.netlify.app/posts/questionscollection/","summary":"问题集锦 这是一个我在学习计算机时遇到或我自己提出的问题的集合 计算机基础 对于Java来说，new是一个创建对象的过程，它存放在那个内存位置 计算","title":"问题集锦（计算机）"},{"content":"主要的资料来源: cs61c\ncache可以说是计算机技术革命中最伟大的想法了\n想一个问题：在我们的电脑里，指令是怎么控制内存里的东西的？因为我们要运行电脑除了CPU以外我们要向外拿取数据才能执行一系列的指令，这样电脑才算运行起来。\n让我们来看下面的这张图，这是十分完整的计算机组成结构：\nComponents of a Computer 我们可以从中看到在CPU需要运行一个进程的时候，首先会将指令告诉主存（main memory）,然后开始在主存中找地址（Address）找到后加载到在CPU内部通用寄存器（register）然后开始执行 执行完后再写入主存中。\n在这里面还有一个步骤，memory要先向disk中读取数据\n其实现实中，CPU通用寄存器的速度和主存之间存在着太大的差异。两者之间的速度大致如下关系：\nOh!!!它们相差1,000倍左右，这是无法想像的，就比如当我前1ns的时候CPU已经做完了，而我还要等1000ns的memory的时间，因此在我们看来CPU此时是空闲的，大大的浪费了。\n因此，如果我们可以提升主存的速度，那么对于系统来说将会获得很大的性能提升。但我们试图提升主存的速度和容量，又期望其成本很低，这就有点难为人了。因此，我们有一种折中的方法，那就是制作一块速度极快但是容量极小的存储设备。那么其成本也不会太高。这块存储设备我们称之为cache。在硬件上，我们将cache放置在CPU和主存之间，作为主存数据的缓存。 当CPU试图从主存中load/store数据的时候， CPU会首先从cache中查找对应地址的数据是否缓存在cache 中。如果其数据缓存在cache中，直接从cache中拿到数据并返回给CPU。\n其实类比的话，我蛮喜欢CS61c里面的Library Analogy，而我自己的想法是有点像现在的物流运输：对一些物品都有一个主要的仓库，而也有一些本地仓，当我要送东西的时候我先去看看本地仓有没有，没有就再去主仓去看看，但时间上就没有本地仓的快\n[[2. Areas/Blog/计算机体系机构/cs61c/SRAM vs. DRAM vs. Disk]]\nMemory Hierarchy 好的现在我们知道了cache的出现了，而下面的图是说明了对于不同的内存级别 cache cache的级别 每一级的cache就是每一个下级内存的副本\ncahe的速度在一定程度上同样影响着系统的性能.当cache中没有缓存我们想要的数据的时候，依然需要漫长的等待从主存中load数据。为了进一步提升性能，引入多级cache。前面提到的cache，称之为L1 cache（第一级cache）。我们在L1 cache 后面连接L2 cache，在L2 cache 和主存之间连接L3 cache。等级越高，速度越慢，容量越大。\nTemporal Locality(时间局部性) If a memory location is referenced then it will tend to be referenced again soon\n比如说我用过一次这个地址,我保存起来以防我下次使用\nSpatial Locality(空间局部性) If a memory location is referenced, the locations with nearby addresses will tend to be referenced soon\n比如一个数组，在我读取的时候它会把数组左右的都读取了\nCache Hit vs Cache Miss 在我要对数据进行查找的时候会出现两种情况Cache Hit \u0026amp;Cache Miss.\ncache hit 你要查找的数据在缓存中 从缓存中检索数据并将其带到处理器.\ncache miss 你要查找的数据不在缓存中 去内存中找数据，把数据放到缓存中，带到处理器中\nCache的工作原理 现在我们来继续说一些快取的工作原理, 在此之前先来说一下的一些名词什么是 line/tag/index/offset/valid\nline: 我们将cache平均分成相等的很多块，每一个块大小称之为cache line也可以叫cache block，其大小是cache line size。 tag: Used to identify the data(用于识别数据)。每条Cache Line前都会有一个独立分配的内存来存tag，其就是内存地址的前N个bits。 $$ addressbits - offsetbits $$\noffset: Identifies the byte offset(标识字节偏移量)。一般是低位后几位。 $$ offset = log_2(line size) $$\nindex: 内存地址后续的bits则是在这\u0026ndash;Way的是Cache Line索引，可以索引Cache Line。 Valid bit: Tells you if the data stored at a given cache line is valid(告诉您存储在给定缓存行中的数据是否有效) 一个地址访问要映射到Cache中，地址被分成三个字段：tag，set index，block offset。这样，通过一个物理地址就可以获取数据或指令在缓存中的位置(set, way, byte)\nDirect mapped cache(直接映射缓存) 优点：直接映射缓存在硬件设计上会更加简单，因此成本上也会较低。\n一句话, 我一个个的加载进入cache,当我的cache满了我就转头再来一遍\n只适合于大容量Cache\n缺点: 继续访问下面的地址时，依然会cache缺失。这就相当于每次访问数据都要从主存中读取，所以cache的存在并没有对性能提升有效,有cache颠簸(每个主存块只有一个固定位置可存放，容易产生冲突)\nTwo-way set associative cache(两路组相连缓存) Cache分了2组\n优点:减少cache颠簸出现频率\n组相联映射实际上是直接映射和全相联映射的折中方案\n缺点: 增加硬件设计复杂读、成本较高(需要比较多个cache line的TAG)\nFully Associative Cache(全相连缓存) 优点:最大程度的降低cache颠簸的频率\n只适合于小容量Cache\n缺点: 增加硬件设计复杂读、成本较高(需要比较多个cache line的TAG)\n扩展：[[More Eviction Policies]]\nTypes of Misses Comparisons 需补充\n","permalink":"https://clever-klepon-d14cb6.netlify.app/posts/cache/","summary":"主要的资料来源: cs61c cache可以说是计算机技术革命中最伟大的想法了 想一个问题：在我们的电脑里，指令是怎么控制内存里的东西的？因为我们要运行电","title":"Cache Note"},{"content":"二进制系统的核心\u0026mdash;bit 众所周知，在计算机里面的所以数据都是由bit表示的，可能这与我们日常使用的十进制来说是十分不方便的，而要想从现实世界的十进制到二进制的过程需要一点点的改变。\n正如我们所想的一样，bit的表示符合物理的形式，更加的底层，也与数学上的息息相关。当我们终究是要从程序员的看发来看bit的，对我们来说，计算机就是通过对bit进行不同方式的编码和描述，来完成和执行不同的任务。\n信息存储 二进制和十六进制 下面是各个进制的转换:\n二进制 十进制 十六进制 二进制 十进制 十六进制 0000 0 0 1000 8 8 0001 1 1 1001 9 9 0010 2 2 1010 10 A 0011 3 3 1011 11 B 0100 4 4 1100 12 C 0101 5 5 1101 13 D 0110 6 6 1110 14 E 0111 7 7 1111 15 F 这是一个十分重要的表格，我们要记得它。\n位， 字节， 字（bit, Byte, word） 我们的一个位就是一bit， 一个字节就是8个bit， 一般32位字长机器一个字就是4个bit。\n如果你问我为什么要这么规定的话，我可以告诉你我也不知道，笑，可以去看看历史，我猜是这样的设计符合机器的一些特性。\n在C语言里面，所有的数据类型都有分配好的字节数，char：1字节、short：2字节、int：4字节、long： 4字节、float：4字节、double：8字节（均在32位机器上）等等。\n分配成这样：\n有规范，可以在不同的机器程序可以运行。 机器没有无限大的内存。 寻址和字节顺序 在内存里，我们把它们抽象成一个一定大的数组块，为每一均匀分布的地址块编上编号(图片)，因此我们要知道多字节的存储顺序，这对于我们在进行网络数据的发送/接收格式，阅读反汇编的时候等等有关系。\n大小端的判定：\n以下是我使用书中的代码看我的电脑是大端还是小端：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 typedef unsigned char *byte_pointer; void show_bytes(byte_pointer start, size_t len) { size_t i; for (size_t i = 0; i \u0026lt; len; i++) { printf(\u0026#34;%.2x \u0026#34;, start[i]); } printf(\u0026#34;\\n\u0026#34;); } void show_int(int x) { show_bytes((byte_pointer)\u0026amp;x, sizeof(int)); } int main(int argc, char const *argv[]) { short a = -12345; unsigned short ua = a; printf(\u0026#34;number = %d\\n\u0026#34;, a); show_int(a); printf(\u0026#34;number = %d\\n\u0026#34;, ua); show_int(ua); return 0; } ==========================\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; $ ./byte number = -12345 c7 cf ff ff number = 53191 c7 cf 00 00 // 我的电脑是小端的 // 系统Linux: Alpine apk-tools 2.12.9, compiled for x86_64. 位的Boolean Algebras 位的布尔运算可以看我的这一篇\n左移和右移的计算 这里我想着重的记下来： 对于左移\u0026lt;\u0026lt;\u0026amp; 右移\u0026gt;\u0026gt; 是对于位的计算，相比于右移来说左移比较简单，在移动的同时往最低位右边补 0 即可。右移的话有两种类型，一种是逻辑右移（左边补 0），另一种是算术右移（左边补符号位）。为什么会有这两种，因为对应无符号数和有符号数的运算是不同的计算方法。\nC语言上的logic计算 不必多言，做题：\n1 2 3 4 5 6 7 8 9 10 11 12 // P76 练习题2.44 int x = foo(); int y = bar(); unsigned ux = x; unsigned uy = y; x \u0026lt; 0 =\u0026gt; ((x * 2) \u0026lt; 0) ux \u0026gt;= 0 x \u0026amp; 7 == 7 =\u0026gt; (x\u0026lt;\u0026lt;30) \u0026lt; 0 ux \u0026gt; -1 x \u0026gt; y =\u0026gt; -x \u0026lt; -y 整数表示 无符号表示 无符号数（unsigned），就是在0~2[^w] - 1范围的数，w是表示字长。有一个重要的特性，就是每个介于0~2[^w]-1 之间的数都有唯一的一个w位的值编码。\nUMin = 0; UMax = 2[^w]−1; 补码表示 补码（Two\u0026rsquo; s Complement）， 就是在-2[^w-1] ~ 2[^w-1] - 1范围的数，补码的出现使得数据的表示得到最好的利用，在运算上和我们的计算自觉一样了，只有一个0没正负之分。\nTMin = -2[^w-1] TMax = 2[^w-1] - 1 我们可以从上面得到一些特性：\n|TMin| = |TMax| + 1 UMax = 2 |TMax| + 1 = 2 |TMin| - 1 整数运算 加法 考虑两个非负整数x 和y, 满足0 \u0026lt; x, y \u0026lt; 2[^w] 。每个数都能表示为w位无符号数字。然而， 如果计算它们的和，我们就有一个可能的范围0 \u0026lt; x+y \u0026lt; 2[^w+1]-2 。我们需要w+1位\n8 11 3（19） 1000 + 1011 = 10011 我们来想想补码的形式，两个数x，y满足-2[^w-1] \u0026lt; x, y \u0026lt; 2[^w-1]-1, 计算它们的和，我们就有一个可能的范围-2[^w] \u0026lt; x + y \u0026lt; 2[^w-1]-2。\n8 11 3（19） 1000 + 1011 = 10011 乘法 无符号数的乘法就是UMul(x,y) = x * y mod 2[^w]\n补码的乘法TMul(x,y) = U2T(x * y mod 2[^w])\n溢出 在我们的运算中（特别是很大的数）不仅仅只考虑算不算的对，还要考虑有没有溢出，一旦我需要的位变成w+1的十分你要十分注意了。\n此时我们要用上扩展与截取：\n扩展：\n对于无符号数，用x位向量表示[xn-1,\u0026hellip;,x0] -\u0026gt;[0,0,0,0,xn-1,\u0026hellip;,x0],用0把剩下的位补齐 对于补码， 用x位向量表示[xn-1,\u0026hellip;,x0] -\u0026gt;[ xn-1,xn-1,xn-1,xn-1,\u0026hellip;,x0],用最高位xn-1把剩下的位补齐 截取： 对于无符号数，UAdd(u,v) = u+v mod 2[^w], UMult(u,v) = u * v mod 2[^w] 对于补码，先把数转换成无符号数再模运算最后再转换补码， TAdd(u,v) = U2T(u+v mod 2[^w]), TMult(u,v) = U2T(u * v mod 2[^w]) 类型转换 无符号数和补码的转换是对位的表示不同来达到转换的过程。\n浮点数（floating point） 关于浮点数，本质上就是我们如何使用二进制来表达一个很大或者很小的数 (类似科学计数法，但是编码上有显著的区别)。\n由于二进制的数值系统在表达能力上存在一定的限制 (位数的限制)，我们实际上没有办法表示所有的数，因此浮点数的设计需要认真的权衡和折中，既要考虑能够表达的范围，也要考虑表达的精度。\n浮点数是一种近似的数，和我们十进制中的小数（或分数）一样，比如：3/10 = 0.333！。所以浮点数在不论大小项目里面都是要十分小心的地方。\nIEEE 浮点表示 IEEE 浮点标准用V=(-1)[^s] M 2[^E]的形式来表示一个数：\n符号(sign) s 决定这数是负数(s=1) 还是正数(s=0), 而对于数值0的符号位解释 作为特殊情况处理(-0.0 = +0.0)。 尾数(significand) M 是一个二进制小数，它的范围是1~2-£, 或者是0~1 - £。 阶码(exponent) E 的作用是对浮点数加权，这个权重是2 的E 次幕（可能是负数） 。 将浮点数的位表示划分为三个字段，分别对这些值进行编码： 一个单独的符号位s 直接编码符号s 。 k 位的阶码字段exp=ek - 1 … e1,e0 编码阶码E 。 n 位小数字段frac= fn-1 \u0026hellip; f1,f0 编码尾数M, 但是编码出来的值也依赖于阶码字 段的值是否等千0 。 在开始时记住一些值的来源：E = exp - Bias；M = 1/0 + f\n规格化的值 当阶数 exp ≠ 000…0和 exp ≠ 111…1时，表示的其实都是规范化的值，这里只需要大概知道因为实数轴上原来连续的值会被规范到有限的定值上并且这些定值之间的间距也是不一样的，具体可以通过后面给出的例子来理解。\n当 exp 的位模式既不全为0(数值0), 也不全为(32位的255，64位的2047)的时候，frac可以随意取值；\nE = exp - Bias(2[^w-1] - 1) M = 1 + f; 例子：\n1 2 3 4 12345 = 0b0011.0000.0011.1001 = 1.1000000111001 * 2[^13] E = 13 = exp - 127 -\u0026gt; exp = 140; M = 1 + f = 1.1000000111001 -\u0026gt; f = 1000000111001; s(1) exp(8) frac(23) 0 10001100 10000001110010000000000 非规格化的值 当exp每一位都为0的时候，可以想象到这时候的数无限的接近数值0，可画个数轴来看，此时的 E = 1 - Bias而且M没有隐含的1表示了，M = f\n第一个功能就是表示0，0的时候exp位为0，frac位为0，符号位的不同使得-0/+0有相同的地方何不同的地方。\n非规格化数的另外一个功能是表示那些非常接近于0.0 的数。它们提供了一种属性，称为逐渐溢出(gradual underflow), 其中，可能的数值分布均匀地接近于0.0 。\n无穷大和NaN 最后一类数值是当指阶码全为1 的时候出现的。当小数域全为0时，得到的值表示无穷，当 s=O 时是 +∞ 或者是 s=1 时是 -∞ 。当我们把两个非常大的数相乘，或者除以零时，无穷能够表示溢出的结果。当小数域为非零时，结果值被称为\u0026quot;NaN\u0026quot;, 即“不是一个数(Not a Number)\u0026quot; 的缩写。一些运算的结果不能是实数或无穷，就会返回这样的NaN值，比如当计算sqrt(-1)或 (∞-∞) 时。在某些应用中，表示未初始化的数据时，它们也很有用处。\n练习 假设一个基于IEEE 浮点格式的5 位浮点表示，有1 个符号位、2 个阶 码位(k=Z) 和两个小数位(n=2) 。阶码偏置量是2[2-1] - 1 = 1 。下表中列举了这个5 位浮点表示的全部非负取值范围。使用下面的条件，填写表格中的空白项：\ne: 假定阶码字段是一个无符号整数所表示的值。\nE: 偏置之后的阶码值。\n2[^E]: 阶码的权重。\nf: 小数值。\nM: 尾数的值。\n2[^E] * M: 该数（未归约的）小数值。\nV: 该数归约后的小数值。\n十进制：该数的十进制表示。\n位 e E 2[^E] f M 2[^E]*M V 十进制 0 00 00 0 0 1 0/4 0/4 0/4 0 0.0 0 00 01 0 0 1 1/4 1/4 1/4 1/4 0.25 0 00 10 0 0 1 2/4 2/4 2/4 1/2 0.5 0 00 11 0 0 1 3/4 3/4 3/4 3/4 0.75 0 01 00 1 0 1 0/4 4/4 4/4 1 1.0 0 01 01 1 0 1 1/4 5/4 5/4 5/4 1.25 0 01 10 1 0 1 2/4 6/4 6/4 3/2 1.5 0 01 11 1 0 1 3/4 7/4 7/4 7/4 1.75 0 10 00 2 1 2 0/4 4/4 8/4 2 2.0 0 10 01 2 1 2 1/4 5/4 10/4 5/2 2.5 0 10 10 2 1 2 2/4 6/4 12/4 3 3.0 0 10 11 2 1 2 3/4 7/4 14/4 7/2 3.5 0 11 00 - - - - - - ∞ - 0 11 01 - - - - - - NaN - 0 11 10 - - - - - - NaN - 0 11 11 - - - - - - NaN - 浮点数的舍入 溢出 1 2 3 4 printf(\u0026#34;浮点数的溢出:\\n\\t\u0026#34;); printf(\u0026#34;(1e20 + (-1e20)) + 3.14 = %lf\\n\\t\u0026#34;, 1e20 + (-1e20) + 3.14); printf(\u0026#34;1e20 + (-1e20 + 3.14) = %lf\\n\u0026#34;, 1e20 + (-1e20 + 3.14)); 浮点数的加乘法 浮点数的加乘法是和我们想的不一样的，它不满足结合律，交换律的，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 x = a + b + c; y = b + c + d; // 编译器可能试图通过产生下列代码来省去一个浮点加法 t = b + c; x = a + t; y = t + d; // 但是对x来说，这个计算可能会产生于原始值不同的值,因为它使用了加法运算的不同结合方式 //浮点数的溢出: (1e20 + (-1e20)) + 3.14 = 3.140000 1e20 + (-1e20 + 3.14) = 0.000000 总结 这一章我们具体的学习了在机器上数的表示，我们用无符号数和补码来表示我的数值，用浮点数表示二进制的科学计数法，数与数的计算，它们是会有溢出的，用模运算来截断防止位溢出。 大多数C 语言实现遵循的原则是底层的位模式不变。在补码机器上，对于一个w 位的值，这种行为是由函数T2Uw 和U2Tw来描述的。C 语言隐式的强制类型转换会出现许多程序员无法预计的结果，常常导致程序错误。\n1 2 int y = (int)(double)y; 我的建议是通读一遍课本，课本比我写的好很多，我想表达的写不出来那个味道，而后再去看看视频会更加的理解。\n外部链接 IEEE754\u0026mdash;wiki 浮点数\u0026mdash;wiki\n","permalink":"https://clever-klepon-d14cb6.netlify.app/posts/csapp01/","summary":"\u003ch1 id=\"二进制系统的核心---bit\"\u003e二进制系统的核心\u0026mdash;bit\u003c/h1\u003e\n\u003cp\u003e众所周知，在计算机里面的所以数据都是由\u003cstrong\u003ebit\u003c/strong\u003e表示的，可能这与我们日常使用的十进制来说是十分不方便的，而要想从现实世界的十进制到二进制的过程需要一点点的改变。\u003c/p\u003e","title":"一.数的表示(CSAPP)"},{"content":"前言 有志，有识，有恒，则断无不成之事 我自己在2022年学习过CS61c，这门课主要是讲解了计算机的体系结构，终于踏入了计算机的门槛。计算机体系结构，这是一个计算机十分难啃的一门知识，内容之多、范围之广，无论里面的数的表示、编译原理、CPU的基本架构、内存、虚拟内存、流水线、线程级并行、I/O、OS、网络等等，每个方面都可以单独拎出来成为一门课程。而想要精通这些知识需要耗费大量的时间和精力，即使学习十年也不嫌少。哈哈哈。\n我对计算机的热爱促使我非正式地学习了CS61c（我也不是伯克利的学子，我就小二本的）过后，我发现，它给我的是课堂上没有的一些思想，比如：为什么？通过已经有的事实发出提问（即存在有缘由，而不是想当然的存在即真理）。\n在我上大学的时候我就知道一本神书《深入理解计算机系统》（即：《Computer Systems: A Programmer’s Perspective》），可是一直没有机会读一读 『也看不懂 :(』 也正是在有CS61c的基础上我想去好好的通读一遍它。\n这本书好在哪里？它是一本以程序员的视角来看计算机的底层机制，不需要你对物理，电子层面有多么高的水准来看计算机，如果有的话更好的（在这里就不得不吐槽国内的教学了）。它里面的内容也是十分的丰富，结合了计算机组成与体系结构，链接与装载，程序优化，内存存储层次，操作系统，网络等基础知识。\n好的，说那么多，我也想把我在学习的过程写下来这也不失成为我的一场回忆。\n学习目的 知其然而不知其所以然\n在看这本书的时候问问自己，这本书可以给我带来什么？我为什么要学习这本书？正如上面的这句话一样，况且我也不想做一个”代码的搬运工“。\n学到什么？ 可以对计算机底层系统有一个更加全面且深入的认识。 系统的理解计算机系统底层的工作原理。 写出更加健壮的、安全的代码。 走向现实层面的计算机。 打下编译原理、操作系统的基础。 等等 学习是要你静下心来，认真思考，积极动手的，用我的话来说就是：事无巨细\n计算机系统漫游 接下来就看看我们要学什么。\n信息bit化 人类与机器交互最大的问题是语言不通。让我们回到五六十年代，那时没有像现在这样方便的手机、iPad和电脑操作方式。那个\u0026quot;古老时代\u0026quot;没有图像、键盘或字符，只有打孔器、巨型电子管和满屋子的电线\u0026hellip;\u0026hellip;我们唯一能与计算机交流的方法就是通过电流和“疯狂”的思维。\n而随着物理学和数学的发展，计算机得以快速发展，并且我们开始使用二进制来与机器进行交互，这比以前好多了。\n但仍然存在一个问题：“为什么要使用二进制？”因为它适用于我们的电路（高/低电压）和逻辑门（0/1），似乎所有事情都变成了二进制。 我们在这里已经迈出了很大的步伐。\n在计算机领域里面，我们叫一个可以正常显示0/1的位叫bit，而后续的研究证明了一次性对8bit进行操作是十分成功的，因此1 Byte = 8 bit(注意大小写)，在后面我们的位越来越多，我们使用了十六进制。由此来看，人类是很富有想象力的种族。\n在后面的学习中，数值的表示是很重要的知识点，计算机就是为精准，快速计算这些数值，特别是浮点数（float）的计算而发展的。\n编译系统 1 2 3 4 5 int main() { printf(\u0026#34;Hello World\\n\u0026#34;); return 0; } 上面是一个简单的C语言程序，打印一个\u0026quot;Hello World\u0026quot;(并且换行)，但是，它要经过好几个步骤才能打印在你的屏幕上，分别是：编译(Compiler)，汇编(Assembler)，装载器(Loader)，链接器(Linker)。\n我们在这一部分将要学到从 高级语言 --\u0026gt; 汇编语言 --\u0026gt; 机器语言 这一过程的具体实现，这使我们能够更深入地了解系统的底层。。\nCPU基本结构 CPU（中央处理器），可以说是本世纪最伟大的发明了，一个小小的芯片装载着人类的智慧，这一部分我们要了解CPU的内部构造，下面是一张CPU的大致图片： 这是一个复杂但十分有趣的部分，相信我，你会体会它的魅力的。\n操作系统 操作系统(Operating System)，是来控制电脑的执行硬件、软件资源，控制I/O操作，提供基本的用户互动等。\n它也负责加载程序、处理服务（如网络堆栈和文件系统）以及为多个程序复用资源，但它实际上是要负责隔离各个程序，使得一个给定的程序不会干扰另一个程序的内存或执行。\n网络通信 这一部分我也写了自己的学习笔记\n外部链接 Computer Science from the Bottom Up\n小土刀博主的『读薄』\nfengmuzi2003up主的计算机系统漫游\n","permalink":"https://clever-klepon-d14cb6.netlify.app/posts/csapp00/","summary":"\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003ch3 id=\"有志有识有恒则断无不成之事\"\u003e有志，有识，有恒，则断无不成之事\u003c/h3\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e我自己在2022年学习过\u003ccode\u003eCS61c\u003c/code\u003e，这门课主要是讲解了计算机的体系结构，终于踏入了计算机的门槛。计算机体系结构，这是一个计算机十分难啃的一门知识，内容之多、范围之广，无论里面的\u003ccode\u003e数的表示、编译原理、CPU的基本架构、内存、虚拟内存、流水线、线程级并行、I/O、OS、网络等等\u003c/code\u003e，每个方面都可以单独拎出来成为一门课程。而想要精通这些知识需要耗费大量的时间和精力，即使学习十年也不嫌少。哈哈哈。\u003c/p\u003e\n\u003cp\u003e我对计算机的热爱促使我非正式地学习了\u003ccode\u003eCS61c\u003c/code\u003e（我也不是伯克利的学子，我就小二本的）过后，我发现，它给我的是课堂上没有的一些思想，比如：为什么？通过已经有的事实发出提问（即存在有缘由，而不是想当然的存在即真理）。\u003c/p\u003e\n\u003cp\u003e在我上大学的时候我就知道一本\u003ccode\u003e神书\u003c/code\u003e《深入理解计算机系统》（即：\u003cem\u003e\u003cstrong\u003e《Computer Systems: A Programmer’s Perspective》\u003c/strong\u003e\u003c/em\u003e），可是一直没有机会读一读 『也看不懂 :(』  也正是在有CS61c的基础上我想去好好的通读一遍它。\u003c/p\u003e\n\u003cp\u003e这本书好在哪里？它是一本以程序员的视角来看计算机的底层机制，不需要你对物理，电子层面有多么高的水准来看计算机，如果有的话更好的（在这里就不得不吐槽国内的教学了）。它里面的内容也是十分的丰富，结合了计算机组成与体系结构，链接与装载，程序优化，内存存储层次，操作系统，网络等基础知识。\u003c/p\u003e\n\u003cp\u003e好的，说那么多，我也想把我在学习的过程写下来这也不失成为我的一场回忆。\u003c/p\u003e","title":"零.深入理解计算机系统(CSAPP)"},{"content":"前言 这是一个根据《计算机网络：自顶向下方法》为主要课本的个人学习笔记。\n导读 在学习计算机的时候不可避免的是网络这个和我们现代生活息息相关的部分。其实在我之前看来，网络是一种我们看不见的东西，它无处不在，你看看你手边的手机，现在眼前的电脑\u0026hellip;\u0026hellip;他们之间有一种莫名的联系，有无形的线使它们链接起来\n当今世界，计算机网络已经成为了人们生活中不可或缺的一部分，它的影响不仅仅只 限于信息交流领域，还涉及到了商业、政治、文化等各个方面。作为一个十分复杂的系统，计算机网络的出现极大地改变了社会的基本交流规律。通过数以万计的网络连接，世界各地的人或物之间得以深度联系，信息的交流、共享和传递变得更加快捷和方便。\n网络的连接也让人们之间的思想交流变得更加广泛、自由与便捷。在这个信息化的时代，网络已经成为了人们相互交流、了解世界的重要途径之一，它让人们能够更加深入地了解各种文化、传统和观点，从而更好地认识自己和他人，增进人类之间的理解和和谐。\n然而，与此同时，网络连接也带来了许多不稳定的因素，例如网络病毒、黑客攻击、网络诈骗等等。这些不利因素威胁着人们信息的安全和隐私，使得网络世界变得更加复杂和危险。因此，在使用网络的过程中，我们必须注意保护自己的信息安全，提高自我保护意识，防范网络风险。\n在我学习计算机网络的过程，《自顶向下》是一本十分优秀的教材，它通过逐层递进的方式，深入浅出地讲解了计算机网络的基本概念和原理，帮助读者快速入门，并逐渐提高自己的网络知识水平。通过学习这本书，可以让我们更好地了解网络的繁星点点，理解计算机网络的运作方式和工作原理，从而更好地掌握网络知识，提高我们的网络应用能力。\n外部链接 中科大郑烇、杨坚全套《计算机网络（自顶向下方法 第7版》\n","permalink":"https://clever-klepon-d14cb6.netlify.app/posts/internet-0/","summary":"前言 这是一个根据《计算机网络：自顶向下方法》为主要课本的个人学习笔记。 导读 在学习计算机的时候不可避免的是网络这个和我们现代生活息息相关的部分","title":"零.计算机网络导读"},{"content":"前言 在计算机里面，所有的数据都是以二进制来进行存储的, 那么，我们在计算的时候不仅仅要知道十进制的计算， 也要知道二进制的计算 （+、-、*、/），这些都是叫位运算，即将符号位共同参与运算的运算。\n位运算的种类 接下来来看看有哪些运算\n符号 描述 作用 + 加法 用二进制的方法进行加法运算 - 减法 用二进制的方法进行加法运算 \u0026amp; 与运算 两个位都为1时，结果才为1 | 或运算 两个位都为0时，结果才为0 ^ 异或运算 两个位相同为0，相异为1 ~ 反取 0反1，1反0 \u0026laquo; 左移运算 所有二进位全部左移位，高位丢弃，低位补0 \u0026raquo; 右移运算 所有二进位全部右移位，对无符号数，高位补0；有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移） 计算方式 加法和减法就不再过多赘述！！！\n\u0026lsquo;\u0026amp;\u0026rsquo; 与运算 和AND一样\n1 2 3 4 0 \u0026amp; 0 = 0 0 \u0026amp; 1 = 0 1 \u0026amp; 0 = 0 1 \u0026amp; 1 = 1 **负数**按*补码*形式参加按位与运算。\r\u0026lsquo;|\u0026rsquo; 或运算 和OR一样\n1 2 3 4 0 | 0 = 0 0 | 1 = 1 1 | 0 = 1 1 | 1 = 1 **负数**按 *补码* 形式参加按位或运算。\r\u0026lsquo;^\u0026rsquo; 异或运算 和AOR一样\n1 2 3 4 0 ^ 0 = 0 0 ^ 1 = 1 1 ^ 0 = 1 1 ^ 1 = 0 \u0026lsquo;~\u0026rsquo; 取反运算 与NOT一样\n1 2 ~1 = 0 ~0 = 1 \u0026lsquo;\u0026laquo;\u0026rsquo; 和 \u0026lsquo;\u0026raquo;\u0026rsquo; 左右位移运算 将一个运算对象的各二进制位全部左（右）移若干位左(右)边的二进制位丢弃，右边补0\n1 2 3 a = 1010 0101; # a \u0026lt;\u0026lt; (\u0026gt;\u0026gt;) n a \u0026lt;\u0026lt; 2 --------- \u0026gt; a = 1001 0100; a \u0026gt;\u0026gt; 2 --------- \u0026gt; a = 0010 1001; 总结 在进行计算的时候，计算机中的数在内存中都是以二进制形式进行存储的，用位运算就是直接对整数在内存中的二进制位进行操作，因此其执行效率非常高，在程序中尽量使用位运算进行操作，这不仅可以锻炼自己的二进制运算，还会大大提高程序的性能。\n外部链接 此博客参考菜鸟教程-C语言中的位运算\n","permalink":"https://clever-klepon-d14cb6.netlify.app/posts/bitsoperation/","summary":"\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\n\u003cp\u003e在计算机里面，所有的数据都是以二进制来进行存储的,\n那么，我们在计算的时候不仅仅要知道十进制的计算，\n也要知道二进制的计算 （+、-、*、/），这些都是叫位运算，即将符号位共同参与运算的运算。\u003c/p\u003e","title":"奇妙的位运算"},{"content":"前言 在我学习c语言的时候我在想计算机是怎么知道我在写什么的，后面在我学习到了cs61c后我知道了汇编语言和底层语言（计算机语言），而RISC很好的帮助我们深入计算机去了解汇编语言。\nRISC-v的寄存器功能 RV32 有 32 个寄存器，而编号从x0到x31，且这32个各有各的作用，对这 32 个寄存器的定义如下：其中 ABI 是寄存器的二进制接口的名称，可以在汇编中使用。\n寄存器编号 寄存器 ABI 名称 寄存器功能 x0 zero 全0寄存器 x1 ra 跳转返回指针 x2 sp 栈指针 x3 gp 全局指针 x4 tp 线程指针 x5 t0 临时存储器 x6 t1 临时存储器 x7 t2 临时存储器 x8 s0/fp 存储寄存器，框架指针 x9 s1 存储寄存器 x10 a0 函数参数寄存器（可用于返回值） x11 a1 函数参数寄存器（可用于返回值） x12-x17 a2-a7 函数参数寄存器 x18-x27 s2-s11 存储寄存器 x28-x31 t3-t6 临时存储器 RISC的指令集 RISC是有47个指令的，而这47个指令能完成所有的现代操作系统的运行基本要求。\n为了方便学习，将指令集进行分类\n6种基本整数指令集 整数运算指令：实现算术、逻辑、比较等运算。 具有 7 条算数运算指令，分别是 add, addi, sub, slt, sltu, slti, sltiu\n1 2 3 4 5 6 7 add rd, rs1, rs2 # 是将 rs1 和 rs2 相加并写入 rd 中 addi rd, rs1, imm # 是将 rs1 和 imm 相加 sub rd,rs1,rs2 # 是将 rs1 减去 rs2 并写入 rd 中 slt # 是有符号的比较指令，即 rs1 小于 rs2 则置 1，否者置 0 sltu # 是无符号的比较指令，即 rs1 小于 rs2 则置 1，否者置 0 slti # 是 rs1 小于立即数则置 1，否者置 0。 sltiu 分支转移指令：实现条件转移、无条件转移等运算，并且没有延迟槽。 加载存储指令：实现字节、半字、字的加载、存储操作，采用的都是寄存器相对寻址方式。 控制与状态寄存器访问指令：实现对系统控制与状态寄存器的原子读-写、原子读-修改、原子读-清零等操作。 系统调用指令：实现系统调用、调试等功能。 ","permalink":"https://clever-klepon-d14cb6.netlify.app/posts/risc-v/","summary":"前言 在我学习c语言的时候我在想计算机是怎么知道我在写什么的，后面在我学习到了cs61c后我知道了汇编语言和底层语言（计算机语言），而RISC","title":"RISC-v前言"},{"content":"介绍自己 我是一个大二在校学生，专业是CS；爱好打游戏,主要是一些模拟类游戏笑；在学习日语和英语（不会😥）；\n我喜欢计算机的高效和开源自由，我希望能结交到一些志同道合的小伙伴和前辈们；\n私たちの未来はみんなでつくる\n第三个博客 这个博客我将不定期的更新，想要做一名程序员，因为我是个新人，目标是星辰大海（bushi），还有在我进行自学的同时，我会把一些我的问题和心得分享出来，也希望看到的小伙伴能指点和讨论。\n最后 我不知道的是这个博客能维持多久，但是我会在力所能及的精力上来完成它，希望几年过后可以看到不一样的风采。\n我知道刚开始说这种话是不好的，但所谓计划赶不上变化罢了\n","permalink":"https://clever-klepon-d14cb6.netlify.app/about/","summary":"about","title":"About Me"},{"content":"","permalink":"https://clever-klepon-d14cb6.netlify.app/blog/","summary":"blog","title":"Blog"}]